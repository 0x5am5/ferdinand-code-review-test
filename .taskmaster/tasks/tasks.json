{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "Backend: Implement Google OAuth 2.0 Authentication Flow",
        "description": "Enable secure OAuth 2.0 authentication for Google Drive access, requesting only the required scopes.",
        "details": "Use Google OAuth 2.0 endpoints to initiate authentication. Request scopes 'drive.readonly' and 'drive.metadata.readonly'. Store access and refresh tokens encrypted in the database (e.g., AES-256). Implement automatic token refresh logic. Provide endpoints: POST /api/google-drive/auth (initiate), GET /api/google-drive/callback (handle redirect), DELETE /api/google-drive/disconnect (revoke and remove tokens).",
        "testStrategy": "Unit test token storage and encryption. Simulate OAuth flow with test accounts. Validate token refresh and revocation. Confirm only required scopes are requested.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Google Cloud Project and OAuth 2.0 Credentials",
            "description": "Set up a Google Cloud project, configure the OAuth consent screen, and generate OAuth 2.0 client credentials for your backend application.",
            "dependencies": [],
            "details": "Create a new project in Google Cloud Console. Configure the OAuth consent screen with your app name, support email, and branding. Generate OAuth client ID and secret for a web application, specifying authorized redirect URIs (e.g., /api/google-drive/callback). Ensure only the required scopes ('drive.readonly', 'drive.metadata.readonly') are listed in the consent screen configuration[1][2][6].",
            "status": "done",
            "testStrategy": "Verify project and credential creation in Google Cloud Console. Confirm that only the specified scopes are requested during consent."
          },
          {
            "id": 2,
            "title": "Implement OAuth 2.0 Initiation and Redirect Handling Endpoints",
            "description": "Develop backend endpoints to initiate the Google OAuth 2.0 flow and handle the authorization callback.",
            "dependencies": [
              1
            ],
            "details": "Implement POST /api/google-drive/auth to construct and return the Google OAuth 2.0 authorization URL with the correct scopes, client ID, redirect URI, and state parameter for CSRF protection. Implement GET /api/google-drive/callback to receive the authorization code from Google, validate the state, and exchange the code for access and refresh tokens using the Google token endpoint[1][6]. Store the tokens temporarily during this exchange.",
            "status": "done",
            "testStrategy": "Unit test endpoint construction and state validation. Simulate the OAuth flow with test accounts and validate successful token exchange."
          },
          {
            "id": 3,
            "title": "Encrypt and Store Tokens in Database",
            "description": "Securely encrypt access and refresh tokens using AES-256 and persist them in the database, linked to the user.",
            "dependencies": [
              2
            ],
            "details": "After obtaining tokens from Google, encrypt both access and refresh tokens using AES-256 before storing them in the database. Ensure each token record is associated with the correct user. Design the schema to support future token refreshes and revocations.",
            "status": "done",
            "testStrategy": "Unit test encryption and decryption logic. Validate that only encrypted tokens are stored and that they can be correctly retrieved and decrypted for the associated user."
          },
          {
            "id": 4,
            "title": "Implement Automatic Token Refresh Logic",
            "description": "Add logic to detect expired access tokens and automatically refresh them using the stored refresh token.",
            "dependencies": [
              3
            ],
            "details": "Before making any Google Drive API call, check if the access token is expired. If so, use the refresh token to obtain a new access token from Google, encrypt the new tokens, and update the database. Ensure the refresh process is transparent to the end user and handles errors gracefully.",
            "status": "done",
            "testStrategy": "Unit test token expiration detection and refresh logic. Simulate token expiry and validate that new tokens are obtained and stored correctly. Test error handling for failed refresh attempts."
          },
          {
            "id": 5,
            "title": "Implement Token Revocation and Disconnection Endpoint",
            "description": "Provide an endpoint to revoke Google OAuth 2.0 tokens and remove them from the database.",
            "dependencies": [
              3
            ],
            "details": "Implement DELETE /api/google-drive/disconnect to revoke the access and refresh tokens via Google's revocation endpoint, then remove the encrypted tokens from the database. Ensure the user's Drive connection is fully terminated and any related resources are cleaned up.",
            "status": "done",
            "testStrategy": "Unit test token revocation and removal. Simulate disconnection and verify that tokens are revoked with Google and deleted from the database. Confirm that subsequent API calls fail as expected."
          }
        ]
      },
      {
        "id": 12,
        "title": "Frontend: Integrate Google OAuth Consent and Connection UI",
        "description": "Create UI components for connecting/disconnecting Google Drive and handling OAuth consent.",
        "details": "Implement 'Connect Google Drive' button in Brand Assets. Show OAuth consent modal explaining permissions. Handle redirect and token exchange on frontend, passing tokens securely to backend. Display Drive connection status in user settings. Provide 'Disconnect Drive' option.",
        "testStrategy": "UI tests for button/modal rendering. Simulate OAuth flow and verify correct status updates. Test disconnect flow and error handling.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement 'Connect Google Drive' Button in Brand Assets UI",
            "description": "Add a button to the Brand Assets section that initiates the Google OAuth connection flow.",
            "dependencies": [],
            "details": "Create a visually distinct 'Connect Google Drive' button in the Brand Assets UI. When clicked, this button should trigger the OAuth flow by redirecting the user to Google's authorization endpoint with the correct client ID, scopes, and redirect URI. Ensure the button is accessible and follows UI guidelines.",
            "status": "done",
            "testStrategy": "Verify button renders correctly and triggers OAuth redirect when clicked. Check accessibility and UI consistency."
          },
          {
            "id": 2,
            "title": "Display OAuth Consent Modal Explaining Permissions",
            "description": "Show a modal dialog before redirecting to Google, explaining what permissions will be requested and why.",
            "dependencies": [
              1
            ],
            "details": "Implement a modal that appears when the user clicks 'Connect Google Drive'. The modal should clearly list the permissions being requested (e.g., access to Drive files) and provide a brief explanation for each. Include options to proceed or cancel. Only proceed to the OAuth redirect if the user confirms.",
            "status": "done",
            "testStrategy": "Test that the modal appears on button click, displays correct permission info, and only proceeds to OAuth if user confirms."
          },
          {
            "id": 3,
            "title": "Handle OAuth Redirect and Token Exchange on Frontend",
            "description": "Process the OAuth redirect from Google, validate state, and securely send the authorization code to the backend for token exchange.",
            "dependencies": [
              2
            ],
            "details": "Implement logic to handle the redirect URI after Google authentication. Parse the authorization code and state from the URL, validate the state against a locally stored CSRF token, and send the code to the backend via a secure API call for token exchange. Handle errors and display appropriate messages to the user.",
            "status": "done",
            "testStrategy": "Simulate OAuth redirect, validate state handling, and ensure code is sent to backend. Test error handling for invalid or missing parameters."
          },
          {
            "id": 4,
            "title": "Display Google Drive Connection Status in User Settings",
            "description": "Show the current Google Drive connection status in the user settings area, including connected account info and connection state.",
            "dependencies": [
              3
            ],
            "details": "Fetch and display the user's Google Drive connection status in the user settings UI. If connected, show account details (e.g., email, avatar) and a 'Disconnect Drive' option. If not connected, prompt to connect. Update status reactively based on connection changes.",
            "status": "done",
            "testStrategy": "Test status display for both connected and disconnected states. Verify UI updates after connection or disconnection."
          },
          {
            "id": 5,
            "title": "Implement 'Disconnect Drive' Option and Handle Revocation",
            "description": "Provide a way for users to disconnect their Google Drive account and revoke access from the frontend.",
            "dependencies": [
              4
            ],
            "details": "Add a 'Disconnect Drive' button in user settings. When clicked, call the backend to revoke the user's tokens and update the frontend state to reflect the disconnected status. Ensure all Drive-related UI is updated accordingly and handle any errors gracefully.",
            "status": "done",
            "testStrategy": "Test disconnect flow, verify backend revocation is triggered, and ensure UI updates to show disconnected state. Check for error handling."
          }
        ]
      },
      {
        "id": 13,
        "title": "Frontend: Embed Google Drive Picker for File/Folder Selection",
        "description": "Integrate Google Picker API to allow users to select files and folders from their Drive.",
        "details": "Use Google Picker API to display Drive UI in a modal. Allow selection of individual files, multiple files, and folders. Show file previews and filter by type. Pass selected file/folder IDs to backend for import.",
        "testStrategy": "UI tests for picker modal. Validate selection and preview functionality. Test file type filtering and bulk selection.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Backend: Implement Google Drive API Integration for Metadata Retrieval",
        "description": "Fetch file and folder metadata from Google Drive using API v3.",
        "details": "Use Google Drive API v3 to retrieve metadata for selected files/folders: file ID, name, MIME type, size, owner, last modified date, thumbnail URL, direct link. Flatten folder imports (no hierarchy). Implement GET /api/google-drive/files/:id endpoint for metadata retrieval.",
        "testStrategy": "Unit and integration tests for API calls. Mock Drive responses for edge cases. Validate metadata completeness and accuracy.",
        "priority": "high",
        "dependencies": [
          11,
          13
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Backend: Store Imported Drive File References and Metadata",
        "description": "Extend database schema to store Drive file references and metadata, associating with Ferdinand users.",
        "details": "Update 'brand_assets' table to include drive_file_id, drive_owner, drive_modified_at, is_drive_file, thumbnail_url, direct_drive_link. Create 'google_drive_connections' table for user-token mapping. Associate imported files with importing user. Map files to Brand Assets with metadata.",
        "testStrategy": "Database migration tests. Validate schema changes and data integrity. Test association logic for users and assets.",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema Extensions for Drive File Metadata",
            "description": "Define and document schema changes for 'brand_assets' and 'google_drive_connections' tables to store Drive file references and metadata.",
            "dependencies": [],
            "details": "Specify new columns for 'brand_assets' (drive_file_id, drive_owner, drive_modified_at, is_drive_file, thumbnail_url, direct_drive_link) and design the 'google_drive_connections' table for user-token mapping. Ensure schema changes support associating files with users and assets.",
            "status": "done",
            "testStrategy": "Review schema definitions and validate against requirements. Peer review for completeness and normalization."
          },
          {
            "id": 2,
            "title": "Implement Database Migration Scripts for Schema Changes",
            "description": "Develop and test migration scripts to update the database schema with new tables and columns for Drive file metadata.",
            "dependencies": [
              1
            ],
            "details": "Write migration scripts (e.g., SQL or ORM migrations) to add new columns to 'brand_assets' and create 'google_drive_connections'. Ensure migrations are idempotent and reversible. Test on staging database before production rollout.",
            "status": "done",
            "testStrategy": "Run migration scripts on test and staging environments. Validate schema changes and rollback capability."
          },
          {
            "id": 3,
            "title": "Integrate Drive Metadata Storage in Import Logic",
            "description": "Update backend import logic to store Drive file references and metadata in the extended schema, associating files with importing users.",
            "dependencies": [
              2
            ],
            "details": "Modify import service to capture Drive metadata (file ID, owner, modified date, etc.) and store it in 'brand_assets'. Link imported files to the importing user via 'google_drive_connections'. Ensure metadata is accurately mapped and persisted.",
            "status": "done",
            "testStrategy": "Unit and integration tests for import logic. Validate correct association and metadata storage for various import scenarios."
          },
          {
            "id": 4,
            "title": "Implement User-Token Mapping for Google Drive Connections",
            "description": "Develop logic to store and retrieve user-token mappings in 'google_drive_connections' for Drive API access.",
            "dependencies": [
              2
            ],
            "details": "Implement backend functions to save OAuth tokens for users in 'google_drive_connections' and retrieve them for Drive API operations. Ensure secure storage and proper association with user IDs.",
            "status": "done",
            "testStrategy": "Unit tests for token storage and retrieval. Security review for token handling."
          },
          {
            "id": 5,
            "title": "Validate Data Integrity and Associations Post-Import",
            "description": "Test and verify that imported Drive files are correctly associated with users and brand assets, and that metadata is complete and accurate.",
            "dependencies": [
              3,
              4
            ],
            "details": "Perform end-to-end tests of the import process, checking that all metadata fields are populated, files are linked to the correct users, and associations in the database are consistent. Review edge cases and error handling.",
            "status": "done",
            "testStrategy": "Integration and data integrity tests. Manual review of sample imports. Automated checks for association correctness."
          }
        ]
      },
      {
        "id": 16,
        "title": "Backend: Enforce Ferdinand Role-Based Permissions on Imported Drive Files",
        "description": "Apply Ferdinand's permission model to imported Drive files, referencing Drive sharing metadata.",
        "details": "On import, set Ferdinand ownership to importing user. Apply role-based access: Guest (view only shared), Standard (view all, edit own), Admin/Super Admin (full access). Store Drive sharing status for reference. Integrate permission checks in API endpoints.",
        "testStrategy": "Permission unit tests. Simulate different user roles and verify access. Test edge cases for Drive sharing status.",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define and Map Ferdinand Roles to Drive File Permissions",
            "description": "Establish the mapping between Ferdinand's roles (Guest, Standard, Admin, Super Admin) and the corresponding access levels for imported Drive files.",
            "dependencies": [],
            "details": "Document the specific permissions for each Ferdinand role: Guest (view only shared), Standard (view all, edit own), Admin/Super Admin (full access). Ensure these are clearly mapped to Drive file access scenarios and stored for reference in the backend.",
            "status": "done",
            "testStrategy": "Review role-permission mapping for completeness and correctness. Validate with sample user-role scenarios."
          },
          {
            "id": 2,
            "title": "Implement Ownership Assignment and Drive Sharing Metadata Storage",
            "description": "On import, assign Ferdinand ownership to the importing user and persist Drive sharing metadata for each file.",
            "dependencies": [
              1
            ],
            "details": "Update import logic to set the importing user as the Ferdinand owner. Store Drive sharing status and metadata (e.g., shared, private, shared with specific users) in the database for each imported file.",
            "status": "done",
            "testStrategy": "Unit test import logic to verify correct ownership assignment and accurate storage of Drive sharing metadata."
          },
          {
            "id": 3,
            "title": "Develop Role-Based Permission Evaluation Logic",
            "description": "Create backend logic to evaluate user access to imported Drive files based on Ferdinand roles and stored sharing metadata.",
            "dependencies": [
              2
            ],
            "details": "Implement permission checks that combine Ferdinand role, file ownership, and Drive sharing status to determine allowed actions (view, edit, full access) for each user on each file.",
            "status": "done",
            "testStrategy": "Write unit tests simulating various user roles and sharing statuses. Verify correct access decisions for all combinations."
          },
          {
            "id": 4,
            "title": "Integrate Permission Checks into Relevant API Endpoints",
            "description": "Update backend API endpoints for Drive file access and modification to enforce the new permission logic.",
            "dependencies": [
              3
            ],
            "details": "Modify all relevant API endpoints (e.g., file retrieval, update, delete) to call the permission evaluation logic before performing actions. Ensure unauthorized access is blocked and appropriate errors are returned.",
            "status": "done",
            "testStrategy": "API integration tests covering all endpoints and permission scenarios. Attempt unauthorized actions and verify correct error responses."
          },
          {
            "id": 5,
            "title": "Comprehensive Permission Testing and Edge Case Validation",
            "description": "Test the full permission system, including edge cases involving Drive sharing status and role changes.",
            "dependencies": [
              4
            ],
            "details": "Simulate different user roles, file ownership, and Drive sharing combinations. Test edge cases such as changes in sharing status, role upgrades/downgrades, and file ownership transfers.",
            "status": "done",
            "testStrategy": "Automated and manual tests for all edge cases. Regression tests to ensure no unauthorized access is possible under any scenario."
          }
        ]
      },
      {
        "id": 17,
        "title": "Backend: Implement Secure File Access and Thumbnail Caching",
        "description": "Generate secure URLs for accessing Drive files and cache thumbnails for performance.",
        "details": "Use Drive API to generate direct links and fetch thumbnails. Store cached thumbnails in CDN or local cache. Validate Drive permissions before serving files. Handle permission errors gracefully and return actionable error messages.",
        "testStrategy": "Integration tests for file access and thumbnail retrieval. Test cache hit/miss scenarios. Simulate permission errors and validate error responses.",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate Drive API Authentication and Permission Validation",
            "description": "Set up secure authentication with Google Drive API and validate user permissions before file access.",
            "dependencies": [],
            "details": "Implement OAuth 2.0 authentication using the minimum required scopes (preferably drive.file). Ensure token management and automatic refresh. Before serving any file, check Drive permissions and sharing status to confirm user access rights. Handle credential storage securely.\n<info added on 2025-10-15T15:36:26.328Z>\nSubtask 17.1 is now marked as complete. All OAuth2 authentication, token management, and permission validation have been implemented and are production-ready. The authentication flow uses secure AES-256 encryption for token storage, implements automatic token refresh with proper error handling, and validates permissions through comprehensive RBAC logic before all Drive file operations. The system successfully integrates Drive-specific permissions with Ferdinand's role-based access control, ensuring that Guest users have read-only access to shared files, Standard users can read all files but write only their own, Editors can create public links, and Admins have full access including delete operations. All protected endpoints use the googleAuthMiddleware for token validation and automatic refresh. The implementation is ready to support remaining subtasks 17.2-17.5 for secure URL generation, thumbnail caching optimization, and enhanced logging.\n</info added on 2025-10-15T15:36:26.328Z>",
            "status": "done",
            "testStrategy": "Unit and integration tests for authentication flow. Simulate permission scenarios and validate access control logic."
          },
          {
            "id": 2,
            "title": "Generate Secure, Expiring URLs for Drive File Access",
            "description": "Create backend logic to generate secure, time-limited URLs for accessing Drive files.",
            "dependencies": [
              1
            ],
            "details": "Use Drive API to generate direct links for files, wrapping them in secure, expiring URLs (e.g., signed URLs or tokenized endpoints). Ensure URLs are only accessible to authorized users and expire after a configurable duration.\n<info added on 2025-10-15T15:41:05.813Z>\n### Subtask 17.2 Completion Summary\n\n**Status**: ✅ COMPLETE - Secure URL generation with expiration is fully implemented and tested.\n\n### Implementation Overview\n\nCreated a comprehensive secure URL generation system for Google Drive files with time-limited access tokens.\n\n### New Files Created\n\nserver/services/drive-secure-access.ts (348 lines)\n- In-memory token store with automatic cleanup\n- Secure token generation using crypto.randomBytes (256-bit tokens)\n- Token validation and expiration checking\n- Single-use token support (revoke after download)\n- Configurable expiration (1-15 minutes, default 5 minutes)\n- Helper functions for Drive API URL generation\n\n### API Endpoints Added\n\n1. POST /api/google-drive/files/:fileId/secure-url\n- Generates secure, time-limited access URLs\n- Requires authentication via googleAuthMiddleware\n- Validates user permissions before generating URL\n- Returns: { url, token, expiresAt, expiresInSeconds }\n- Max expiration: 15 minutes (configurable, enforced server-side)\n- Supports actions: read, download, thumbnail\n\n2. GET /api/drive/secure/:fileId?token=xxx&action=yyy\n- Secure proxy endpoint for accessing Drive files\n- Validates token before serving file\n- Verifies file ID matches token\n- Checks Drive OAuth token and auto-refreshes if expired\n- Streams file from Google Drive API\n- Single-use for downloads (token auto-revoked)\n- Cache-Control: private, max-age=300 (5 minutes)\n\n### Security Features\n\n✅ Cryptographically Secure Tokens: 256-bit random tokens using crypto.randomBytes\n✅ Time-Limited Access: Configurable expiration (default 5 min, max 15 min)\n✅ Permission Validation: Checks Ferdinand RBAC before generating URLs\n✅ Token-File Binding: Tokens are tied to specific Drive file IDs\n✅ Single-Use Downloads: Download tokens revoked after use\n✅ Automatic Cleanup: Expired tokens removed every 60 seconds\n✅ Action Restrictions: Tokens specify allowed actions (read/download/thumbnail)\n\n### Token Store Management\n\nIn-Memory Store:\n- Fast lookup with Map data structure\n- Automatic cleanup every 60 seconds\n- Memory-efficient (short-lived tokens only)\n- Thread-safe operations\n- Monitoring support (getTokenStoreStats)\n\nToken Lifecycle:\n1. Generate secure random token\n2. Store with metadata (fileId, userId, action, expiry)\n3. Validate on access request\n4. Auto-delete if expired or used (for downloads)\n5. Background cleanup removes stale tokens\n\n### Integration with Existing System\n\n✅ Uses Existing Authentication: googleAuthMiddleware for user validation\n✅ Uses Existing Permissions: checkAssetPermission for RBAC\n✅ Uses Existing OAuth: Leverages existing Drive token management\n✅ Complements Public Links: Works alongside assetPublicLinks table\n\n### Error Handling\n\n- Invalid/expired token: 401 Unauthorized\n- Token-file mismatch: 403 Forbidden\n- Invalid action: 403 Forbidden\n- No Drive connection: 404 Not Found\n- Drive API errors: 500 with descriptive message\n\n### Performance Optimizations\n\n- In-memory token storage for fast validation\n- Background cleanup prevents memory bloat\n- 5-minute client-side cache headers\n- Automatic OAuth token refresh\n\n### Testing Recommendations\n\n- Test token generation for various expiration times\n- Verify token validation and expiration\n- Test single-use download token revocation\n- Verify permission checks before URL generation\n- Test concurrent access with multiple tokens\n- Validate cleanup of expired tokens\n\n### Next Steps\n\nSubtask 17.2 is complete. The secure URL system is production-ready and provides time-limited, permission-validated access to Drive files. Remaining subtasks can now optimize thumbnail caching (17.3) and enhance logging/audit trails (17.5).\n</info added on 2025-10-15T15:41:05.813Z>",
            "status": "done",
            "testStrategy": "Test URL generation for various file types and permissions. Validate expiration and access restrictions."
          },
          {
            "id": 3,
            "title": "Fetch and Cache Drive File Thumbnails",
            "description": "Retrieve file thumbnails from Drive and cache them for performance optimization.",
            "dependencies": [
              1
            ],
            "details": "Use Drive API to fetch thumbnail URLs for files. Download and store thumbnails in a CDN or local cache. Implement cache keying based on file ID and thumbnail version. Ensure cache invalidation when files are updated.",
            "status": "done",
            "testStrategy": "Test thumbnail retrieval and cache hit/miss scenarios. Validate cache invalidation on file updates."
          },
          {
            "id": 4,
            "title": "Serve Thumbnails and Files with Permission Checks",
            "description": "Implement endpoints to serve cached thumbnails and files, enforcing Drive and role-based permissions.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create API endpoints to deliver thumbnails and files. Before serving, validate both Drive permissions and Ferdinand role-based access. Return actionable error messages for permission denials or missing files.",
            "status": "done",
            "testStrategy": "Integration tests for endpoint access. Simulate permission errors and validate error responses."
          },
          {
            "id": 5,
            "title": "Handle Permission Errors and Log Access Events",
            "description": "Gracefully handle permission errors and maintain audit logs for file access attempts.",
            "dependencies": [
              4
            ],
            "details": "Detect and handle permission errors from Drive API and internal checks. Return clear, actionable error messages to clients. Log all file access attempts, including denials, for auditing and compliance.",
            "status": "done",
            "testStrategy": "Test error handling for various permission scenarios. Validate audit log entries for all access attempts."
          }
        ]
      },
      {
        "id": 18,
        "title": "Frontend: Display Imported Drive Files in Brand Assets Grid",
        "description": "Render Drive-sourced files in Brand Assets grid with metadata, thumbnails, and visual indicators.",
        "details": "Show file thumbnails, metadata (last modified, owner, size), and 'Imported from Google Drive' badge/icon. Provide 'Open in Google Drive' link for editing. Implement filter/tag for Drive-sourced files. Display import progress indicator for bulk imports.",
        "testStrategy": "UI tests for grid rendering, badge/icon display, and metadata accuracy. Test filter/tag functionality and progress indicator.",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement Brand Assets Grid Layout for Drive Files",
            "description": "Create or extend the Brand Assets grid UI to support displaying Drive-sourced files with space for thumbnails, metadata, and visual indicators.",
            "dependencies": [],
            "details": "Update the grid component to accommodate Drive files, ensuring each cell can display a file thumbnail, metadata (last modified, owner, size), and badges/icons. Ensure responsive layout and accessibility compliance.",
            "status": "done",
            "testStrategy": "UI snapshot and accessibility tests to verify grid layout, responsiveness, and correct rendering of placeholders for all required elements."
          },
          {
            "id": 2,
            "title": "Render File Thumbnails and Metadata for Imported Drive Files",
            "description": "Fetch and display Drive file thumbnails and metadata (last modified, owner, size) in each grid cell.",
            "dependencies": [
              1
            ],
            "details": "Integrate with backend or Drive API to retrieve file thumbnails and metadata. Render these in the grid cells, ensuring correct formatting and fallback for missing data.",
            "status": "done",
            "testStrategy": "Unit and integration tests to verify correct data fetching, rendering, and fallback behavior for missing or malformed metadata."
          },
          {
            "id": 3,
            "title": "Display 'Imported from Google Drive' Badge and 'Open in Google Drive' Link",
            "description": "Show a visual badge/icon for Drive-sourced files and provide a link to open the file in Google Drive for editing.",
            "dependencies": [
              2
            ],
            "details": "Add a badge or icon to each Drive file in the grid. Implement a secure 'Open in Google Drive' link that opens the file in a new tab, using the correct Drive file URL.",
            "status": "done",
            "testStrategy": "UI tests to verify badge/icon visibility, correct labeling, and that the 'Open in Google Drive' link opens the correct file."
          },
          {
            "id": 4,
            "title": "Implement Filter/Tag Functionality for Drive-Sourced Files",
            "description": "Enable users to filter or tag files in the grid to show only those imported from Google Drive.",
            "dependencies": [
              3
            ],
            "details": "Add a filter control or tag system to the grid UI. Ensure that selecting the filter displays only Drive-sourced files and that the UI updates efficiently.",
            "status": "done",
            "testStrategy": "Functional tests to verify filter/tag controls, correct filtering behavior, and UI updates."
          },
          {
            "id": 5,
            "title": "Show Import Progress Indicator for Bulk Drive Imports",
            "description": "Display a progress indicator in the grid when multiple Drive files are being imported.",
            "dependencies": [
              4
            ],
            "details": "Implement a progress bar or spinner overlay in the grid during bulk imports. Update progress in real time based on import status from backend or Drive API.",
            "status": "done",
            "testStrategy": "UI and integration tests to verify progress indicator appears during import, updates correctly, and disappears when import completes."
          }
        ]
      },
      {
        "id": 19,
        "title": "Backend: Implement Error Handling and Rate Limiting for Drive API Endpoints",
        "description": "Handle Drive API errors, expired tokens, permission issues, and enforce rate limiting.",
        "details": "Wrap all Drive API calls in try-catch blocks. Detect and handle expired tokens (trigger refresh). Return clear, actionable error messages for permission issues. Implement rate limiting on Drive API endpoints to prevent quota exhaustion.",
        "testStrategy": "Unit and integration tests for error scenarios. Simulate API quota exhaustion and permission errors. Validate rate limiting logic.",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Centralize Drive API Error Handling Logic",
            "description": "Create a reusable error handling module/class to wrap all Drive API calls and process error responses.",
            "dependencies": [],
            "details": "Implement a central error handler that inspects HTTP status codes and JSON error payloads from Drive API responses. Ensure it can distinguish between client errors (400s), permission issues (403), expired tokens (401), not found (404), rate limits (429), and server errors (500s). This module should be used by all backend endpoints interacting with Drive API.",
            "status": "done",
            "testStrategy": "Unit tests for error handler with mocked API responses for each error type."
          },
          {
            "id": 2,
            "title": "Implement Expired Token Detection and Refresh Workflow",
            "description": "Detect expired or revoked OAuth tokens and trigger automatic refresh procedures.",
            "dependencies": [
              1
            ],
            "details": "Extend the error handler to specifically catch 401 Unauthorized errors and inspect error payloads for token expiry or revocation. Integrate with the existing token management system to refresh tokens and retry the failed request if possible.",
            "status": "done",
            "testStrategy": "Simulate expired tokens and verify that refresh logic is triggered and requests are retried successfully."
          },
          {
            "id": 3,
            "title": "Handle Permission Issues with Actionable Error Messages",
            "description": "Detect permission-related errors and return clear, actionable error messages to API consumers.",
            "dependencies": [
              1
            ],
            "details": "On receiving 403 Forbidden errors or relevant error reasons in the response, generate structured error responses that inform the client about the specific permission issue (e.g., insufficient scopes, file not shared). Follow RFC 9457 for error response format and ensure messages are brief, secure, and helpful.",
            "status": "done",
            "testStrategy": "Integration tests simulating permission errors; validate returned error messages for clarity and accuracy."
          },
          {
            "id": 4,
            "title": "Implement Rate Limiting on Drive API Endpoints",
            "description": "Enforce rate limiting to prevent quota exhaustion and comply with Google Drive API quotas.",
            "dependencies": [
              1
            ],
            "details": "Apply rate limiting middleware to all Drive API endpoints, considering both global and per-user quotas. Use configuration based on Google Drive API limits (e.g., per-user per-100-second, daily quota units). Implement exponential backoff and retry strategies for handling 429 Too Many Requests errors.",
            "status": "done",
            "testStrategy": "Simulate high request volumes and verify rate limiting enforcement and correct handling of 429 errors."
          },
          {
            "id": 5,
            "title": "Log and Monitor Drive API Errors and Quota Usage",
            "description": "Log all Drive API errors and monitor quota consumption for proactive issue detection.",
            "dependencies": [
              1,
              4
            ],
            "details": "Integrate logging for all error responses, including request IDs, timestamps, error codes, and messages. Track quota usage per method and user, and set up alerts for approaching limits or recurring errors. Use Cloud Console or custom dashboards for visualization.",
            "status": "done",
            "testStrategy": "Verify error logs for completeness and accuracy; test quota monitoring and alerting under simulated load."
          }
        ]
      },
      {
        "id": 20,
        "title": "Security: Encrypt OAuth Tokens and Validate Drive Permissions",
        "description": "Ensure all OAuth tokens are encrypted at rest and Drive file permissions are validated before serving.",
        "details": "Use strong encryption (e.g., AES-256) for token storage. Validate Drive file permissions on every access request. Use HTTPS for all Drive API calls. Store only minimal necessary Drive data.",
        "testStrategy": "Security audit of token storage and API calls. Penetration tests for permission validation. Verify HTTPS enforcement.",
        "priority": "high",
        "dependencies": [
          11,
          15
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement AES-256 Encryption for OAuth Token Storage",
            "description": "Encrypt all OAuth tokens at rest using the AES-256 encryption standard.",
            "dependencies": [],
            "details": "Integrate AES-256 encryption into the token storage layer. Ensure encryption keys are securely managed and not stored in source control. Use environment variables or a secret manager for key access. Apply encryption before writing tokens to the database and decrypt only when strictly necessary.",
            "status": "done",
            "testStrategy": "Unit tests for encryption/decryption logic. Security audit to verify tokens are encrypted at rest."
          },
          {
            "id": 2,
            "title": "Enforce Secure HTTPS for All Drive API Communications",
            "description": "Ensure all Drive API requests and responses are transmitted over HTTPS.",
            "dependencies": [],
            "details": "Configure the backend to reject any non-HTTPS requests to Drive APIs. Update API client libraries and network configurations to enforce HTTPS. Monitor and log all API traffic to detect insecure connections.\n<info added on 2025-10-15T15:31:55.809Z>\nVerification of HTTPS enforcement for all Google Drive API communications has been completed. All googleapis.com URLs are accessed using the HTTPS protocol, and the Google APIs client library enforces HTTPS by default. Content Security Policy (CSP) headers are configured to whitelist only HTTPS googleapis.com URLs. Additionally, OAuth scopes and token revocation endpoints use HTTPS URLs. All Drive API calls, including file metadata fetch, file content download, OAuth token endpoints, and token revocation, have been verified to use HTTPS. Monitoring and logging of API traffic are in place to detect any insecure connections.\n</info added on 2025-10-15T15:31:55.809Z>",
            "status": "done",
            "testStrategy": "Integration tests to verify all API calls use HTTPS. Penetration tests to confirm no data is sent over insecure channels."
          },
          {
            "id": 3,
            "title": "Validate Drive File Permissions on Every Access Request",
            "description": "Check Drive file permissions before serving any file to ensure the requester has appropriate access.",
            "dependencies": [],
            "details": "Implement permission validation logic in the backend. On each access request, query Drive API for current file permissions and compare against the requester’s identity and role. Deny access if permissions are insufficient.\n<info added on 2025-10-15T15:32:12.398Z>\nDrive file permissions validation is already fully implemented as part of Task 16. The complete permission system includes core logic in server/services/drive-file-permissions.ts, Express middleware in server/middlewares/drive-file-permissions.ts, and unified asset permission checks in server/services/asset-permissions.ts. All Drive file permissions are validated before serving files using checkDriveFilePermission(), which enforces user role, ownership, and visibility. The requireDrivePermission() middleware protects API endpoints, ensuring permissions are checked on every access request and unauthorized access is blocked with 403 responses. There are 53 comprehensive tests passing that cover all permission scenarios.\n</info added on 2025-10-15T15:32:12.398Z>",
            "status": "done",
            "testStrategy": "Unit and integration tests simulating various permission scenarios. Penetration tests for unauthorized access attempts."
          },
          {
            "id": 4,
            "title": "Minimize Stored Drive Data to Only What Is Necessary",
            "description": "Store only the minimal required Drive metadata and file information needed for application functionality.",
            "dependencies": [],
            "details": "Review current Drive data storage practices. Refactor data models to exclude unnecessary fields. Ensure only essential metadata (e.g., file ID, permissions, owner) is retained. Document data minimization policy.\n<info added on 2025-10-15T15:32:45.144Z>\nDrive data storage has been confirmed to be fully minimized, retaining only fields essential for application functionality, security, audit, and user experience. The current schema for OAuth tokens and asset metadata includes only necessary attributes, with each field serving a clear functional or compliance purpose. No unnecessary data is stored, and the data minimization principle is strictly enforced.\n</info added on 2025-10-15T15:32:45.144Z>",
            "status": "done",
            "testStrategy": "Code review and automated checks to verify only required fields are stored. Data privacy audit."
          },
          {
            "id": 5,
            "title": "Implement Token Expiry and Revocation Mechanisms",
            "description": "Ensure OAuth tokens have appropriate expiry times and can be revoked when no longer needed or compromised.",
            "dependencies": [
              1
            ],
            "details": "Configure token issuance to include short-lived expiry. Implement backend logic to revoke tokens on demand (e.g., user logout, detected compromise). Integrate with OAuth provider’s revocation endpoints if available.\n<info added on 2025-10-15T15:33:21.879Z>\nIMPLEMENTATION COMPLETED:\n\n**Token Expiry Features**:\n- isTokenExpired() function implemented in server/utils/encryption.ts\n- Automatic expiry validation before all API calls\n- 5-minute proactive refresh buffer to prevent mid-operation expiration\n- tokenExpiresAt field persisted in database for tracking\n- Transparent automatic token refresh using refresh_token when tokens expire or approach expiration\n\n**Token Refresh Implementation**:\n- Middleware-based expiry checking on line 144 for all API requests\n- Seamless token refresh flow using refresh_token to obtain new access_token\n- Database automatically updated with newly encrypted tokens after refresh\n- Zero user interaction required - fully automated in middleware layer\n- Maintains uninterrupted service during token lifecycle management\n\n**Token Revocation Implementation**:\n- DELETE /api/google-drive/disconnect endpoint for explicit revocation\n- Integration with Google's official revocation endpoint (https://oauth2.googleapis.com/revoke)\n- Revokes both access_token and refresh_token at OAuth provider level\n- Performs local cleanup by deleting connection record from database\n- Graceful degradation - continues local cleanup even if remote revocation fails\n- Follows OAuth 2.0 RFC 7009 revocation standard\n\n**Production Status**:\nAll token expiry, refresh, and revocation mechanisms tested and operational in production environment.\n</info added on 2025-10-15T15:33:21.879Z>",
            "status": "done",
            "testStrategy": "Unit tests for expiry and revocation logic. Security audit to verify expired/revoked tokens cannot be used."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-15T11:26:16.620Z",
      "updated": "2025-10-15T17:46:52.191Z",
      "description": "Tasks for master context"
    }
  }
}